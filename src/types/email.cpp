#include <tegia/types/email.h>

namespace tegia {
namespace types {


////////////////////////////////////////////////////////////////////////////////////////////
/**
		
*/   
////////////////////////////////////////////////////////////////////////////////////////////


email_t::email_t():base_t("email")
{
	
};


////////////////////////////////////////////////////////////////////////////////////////////
/**
		
*/   
////////////////////////////////////////////////////////////////////////////////////////////


std::string email_t::value() const
{
	return this->_email;
};


////////////////////////////////////////////////////////////////////////////////////////////
/**
		
*/   
////////////////////////////////////////////////////////////////////////////////////////////


std::string email_t::hash() const
{
	return tegia::crypt::MD5(this->_email);
};


////////////////////////////////////////////////////////////////////////////////////////////
/**
		
*/   
////////////////////////////////////////////////////////////////////////////////////////////


nlohmann::json email_t::json() const
{
	nlohmann::json tmp;
	tmp["email"] = this->_email;

	return std::move(tmp);
};


////////////////////////////////////////////////////////////////////////////////////////////
/**
		
	0 - empty
	1 - ok
	2 - not valid

*/   
////////////////////////////////////////////////////////////////////////////////////////////


int email_t::parse(const std::string & value, const nlohmann::json &validate)
{

	if(value == "")
	{
		this->_email = value;
		this->_is_valid = false;
		return 0;
	}

	// TODO: Хотя бы минимальную валидацию
	
	this->_email = value;

	std::transform(
		this->_email.begin(), 
		this->_email.end(), 
		this->_email.begin(),
		[](unsigned char c){ return std::tolower(c); }
	);
	
	this->_is_valid = true;
	return 1;
};



}	// END namespace types
}	// END namespace tegia
