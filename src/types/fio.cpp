#include <tegia/types/fio.h>

namespace tegia {
namespace types {


////////////////////////////////////////////////////////////////////////////////////////////
/**
		
*/   
////////////////////////////////////////////////////////////////////////////////////////////


fio_t::fio_t():base_t("fio")
{
	
};


////////////////////////////////////////////////////////////////////////////////////////////
/**
		
*/   
////////////////////////////////////////////////////////////////////////////////////////////


std::string fio_t::value() const
{
	return this->_fio;
};


////////////////////////////////////////////////////////////////////////////////////////////
/**
		
*/   
////////////////////////////////////////////////////////////////////////////////////////////


std::string fio_t::hash() const
{
	return tegia::crypt::MD5u(this->_fio);
};


////////////////////////////////////////////////////////////////////////////////////////////
/**
		
*/   
////////////////////////////////////////////////////////////////////////////////////////////


nlohmann::json fio_t::json() const
{
	nlohmann::json tmp;
	tmp["fio"] = this->_fio;

	return std::move(tmp);
};


////////////////////////////////////////////////////////////////////////////////////////////
/**
		
*/   
////////////////////////////////////////////////////////////////////////////////////////////


int fio_t::parse(const std::string &value, const nlohmann::json &validate)
{
	if(value == "")
	{
		this->_fio = value;
		this->_is_valid = false;
		return 0;
	}

	// TODO: Хотя бы минимальную валидацию
	
	this->_fio = value;
	this->_is_valid = true;
	return 1;
};



}	// END namespace identifier
}	// END namespace tegia
